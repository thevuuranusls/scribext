/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "BucketStoreMapping.h"

namespace scribe {
    namespace thrift {

        uint32_t BucketStoreMapping_getMapping_args::read(::apache::thrift::protocol::TProtocol* iprot) {

            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->category);
                            this->__isset.category = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t BucketStoreMapping_getMapping_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            xfer += oprot->writeStructBegin("BucketStoreMapping_getMapping_args");

            xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->category);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        uint32_t BucketStoreMapping_getMapping_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            xfer += oprot->writeStructBegin("BucketStoreMapping_getMapping_pargs");

            xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString((*(this->category)));
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        uint32_t BucketStoreMapping_getMapping_result::read(::apache::thrift::protocol::TProtocol* iprot) {

            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 0:
                        if (ftype == ::apache::thrift::protocol::T_MAP) {
                            {
                                this->success.clear();
                                uint32_t _size0;
                                ::apache::thrift::protocol::TType _ktype1;
                                ::apache::thrift::protocol::TType _vtype2;
                                xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
                                uint32_t _i4;
                                for (_i4 = 0; _i4 < _size0; ++_i4) {
                                    int32_t _key5;
                                    xfer += iprot->readI32(_key5);
                                    HostPort& _val6 = this->success[_key5];
                                    xfer += _val6.read(iprot);
                                }
                                xfer += iprot->readMapEnd();
                            }
                            this->__isset.success = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->e.read(iprot);
                            this->__isset.e = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t BucketStoreMapping_getMapping_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

            uint32_t xfer = 0;

            xfer += oprot->writeStructBegin("BucketStoreMapping_getMapping_result");

            if (this->__isset.success) {
                xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
                {
                    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t> (this->success.size()));
                    std::map<int32_t, HostPort> ::const_iterator _iter7;
                    for (_iter7 = this->success.begin(); _iter7 != this->success.end(); ++_iter7) {
                        xfer += oprot->writeI32(_iter7->first);
                        xfer += _iter7->second.write(oprot);
                    }
                    xfer += oprot->writeMapEnd();
                }
                xfer += oprot->writeFieldEnd();
            } else if (this->__isset.e) {
                xfer += oprot->writeFieldBegin("e", ::apache::thrift::protocol::T_STRUCT, 1);
                xfer += this->e.write(oprot);
                xfer += oprot->writeFieldEnd();
            }
            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        uint32_t BucketStoreMapping_getMapping_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 0:
                        if (ftype == ::apache::thrift::protocol::T_MAP) {
                            {
                                (*(this->success)).clear();
                                uint32_t _size8;
                                ::apache::thrift::protocol::TType _ktype9;
                                ::apache::thrift::protocol::TType _vtype10;
                                xfer += iprot->readMapBegin(_ktype9, _vtype10, _size8);
                                uint32_t _i12;
                                for (_i12 = 0; _i12 < _size8; ++_i12) {
                                    int32_t _key13;
                                    xfer += iprot->readI32(_key13);
                                    HostPort& _val14 = (*(this->success))[_key13];
                                    xfer += _val14.read(iprot);
                                }
                                xfer += iprot->readMapEnd();
                            }
                            this->__isset.success = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->e.read(iprot);
                            this->__isset.e = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        void BucketStoreMappingClient::getMapping(std::map<int32_t, HostPort> & _return, const std::string& category) {
            send_getMapping(category);
            recv_getMapping(_return);
        }

        void BucketStoreMappingClient::send_getMapping(const std::string& category) {
            int32_t cseqid = 0;
            oprot_->writeMessageBegin("getMapping", ::apache::thrift::protocol::T_CALL, cseqid);

            BucketStoreMapping_getMapping_pargs args;
            args.category = &category;
            args.write(oprot_);

            oprot_->writeMessageEnd();
            oprot_->getTransport()->writeEnd();
            oprot_->getTransport()->flush();
        }

        void BucketStoreMappingClient::recv_getMapping(std::map<int32_t, HostPort> & _return) {

            int32_t rseqid = 0;
            std::string fname;
            ::apache::thrift::protocol::TMessageType mtype;

            iprot_->readMessageBegin(fname, mtype, rseqid);
            if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
                ::apache::thrift::TApplicationException x;
                x.read(iprot_);
                iprot_->readMessageEnd();
                iprot_->getTransport()->readEnd();
                throw x;
            }
            if (mtype != ::apache::thrift::protocol::T_REPLY) {
                iprot_->skip(::apache::thrift::protocol::T_STRUCT);
                iprot_->readMessageEnd();
                iprot_->getTransport()->readEnd();
            }
            if (fname.compare("getMapping") != 0) {
                iprot_->skip(::apache::thrift::protocol::T_STRUCT);
                iprot_->readMessageEnd();
                iprot_->getTransport()->readEnd();
            }
            BucketStoreMapping_getMapping_presult result;
            result.success = &_return;
            result.read(iprot_);
            iprot_->readMessageEnd();
            iprot_->getTransport()->readEnd();

            if (result.__isset.success) {
                // _return pointer has now been filled
                return;
            }
            if (result.__isset.e) {
                throw result.e;
            }
            throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getMapping failed: unknown result");
        }

        bool BucketStoreMappingProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
            ProcessMap::iterator pfn;
            pfn = processMap_.find(fname);
            if (pfn == processMap_.end()) {
                iprot->skip(::apache::thrift::protocol::T_STRUCT);
                iprot->readMessageEnd();
                iprot->getTransport()->readEnd();
                ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '" + fname + "'");
                oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
                x.write(oprot);
                oprot->writeMessageEnd();
                oprot->getTransport()->writeEnd();
                oprot->getTransport()->flush();
                return true;
            }
            (this->*(pfn->second))(seqid, iprot, oprot, callContext);
            return true;
        }

        void BucketStoreMappingProcessor::process_getMapping(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext) {
            void* ctx = NULL;
            if (this->eventHandler_.get() != NULL) {
                ctx = this->eventHandler_->getContext("BucketStoreMapping.getMapping", callContext);
            }
            ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "BucketStoreMapping.getMapping");

            if (this->eventHandler_.get() != NULL) {
                this->eventHandler_->preRead(ctx, "BucketStoreMapping.getMapping");
            }

            BucketStoreMapping_getMapping_args args;
            args.read(iprot);
            iprot->readMessageEnd();
            uint32_t bytes = iprot->getTransport()->readEnd();

            if (this->eventHandler_.get() != NULL) {
                this->eventHandler_->postRead(ctx, "BucketStoreMapping.getMapping", bytes);
            }

            BucketStoreMapping_getMapping_result result;
            try {
                iface_->getMapping(result.success, args.category);
                result.__isset.success = true;
            } catch (BucketStoreMappingException &e) {
                result.e = e;
                result.__isset.e = true;
            } catch (const std::exception& e) {
                if (this->eventHandler_.get() != NULL) {
                    this->eventHandler_->handlerError(ctx, "BucketStoreMapping.getMapping");
                }

                ::apache::thrift::TApplicationException x(e.what());
                oprot->writeMessageBegin("getMapping", ::apache::thrift::protocol::T_EXCEPTION, seqid);
                x.write(oprot);
                oprot->writeMessageEnd();
                oprot->getTransport()->writeEnd();
                oprot->getTransport()->flush();
                return;
            }

            if (this->eventHandler_.get() != NULL) {
                this->eventHandler_->preWrite(ctx, "BucketStoreMapping.getMapping");
            }

            oprot->writeMessageBegin("getMapping", ::apache::thrift::protocol::T_REPLY, seqid);
            result.write(oprot);
            oprot->writeMessageEnd();
            bytes = oprot->getTransport()->writeEnd();
            oprot->getTransport()->flush();

            if (this->eventHandler_.get() != NULL) {
                this->eventHandler_->postWrite(ctx, "BucketStoreMapping.getMapping", bytes);
            }
        }

        ::boost::shared_ptr< ::apache::thrift::TProcessor > BucketStoreMappingProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
            ::apache::thrift::ReleaseHandler< BucketStoreMappingIfFactory > cleanup(handlerFactory_);
            ::boost::shared_ptr< BucketStoreMappingIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
            ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new BucketStoreMappingProcessor(handler));
            return processor;
        }
    }
} // namespace

