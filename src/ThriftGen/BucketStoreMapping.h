/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef BucketStoreMapping_H
#define BucketStoreMapping_H

#include <thrift/TDispatchProcessor.h>
#include "bucketupdater_types.h"

namespace scribe {
    namespace thrift {

        class BucketStoreMappingIf {
        public:

            virtual ~BucketStoreMappingIf() {
            }
            virtual void getMapping(std::map<int32_t, HostPort> & _return, const std::string& category) = 0;
        };

        class BucketStoreMappingIfFactory {
        public:
            typedef BucketStoreMappingIf Handler;

            virtual ~BucketStoreMappingIfFactory() {
            }

            virtual BucketStoreMappingIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
            virtual void releaseHandler(BucketStoreMappingIf* /* handler */) = 0;
        };

        class BucketStoreMappingIfSingletonFactory : virtual public BucketStoreMappingIfFactory {
        public:

            BucketStoreMappingIfSingletonFactory(const boost::shared_ptr<BucketStoreMappingIf>& iface) : iface_(iface) {
            }

            virtual ~BucketStoreMappingIfSingletonFactory() {
            }

            virtual BucketStoreMappingIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
                return iface_.get();
            }

            virtual void releaseHandler(BucketStoreMappingIf* /* handler */) {
            }

        protected:
            boost::shared_ptr<BucketStoreMappingIf> iface_;
        };

        class BucketStoreMappingNull : virtual public BucketStoreMappingIf {
        public:

            virtual ~BucketStoreMappingNull() {
            }

            void getMapping(std::map<int32_t, HostPort> & /* _return */, const std::string& /* category */) {
                return;
            }
        };

        typedef struct _BucketStoreMapping_getMapping_args__isset {

            _BucketStoreMapping_getMapping_args__isset() : category(false) {
            }
            bool category;
        } _BucketStoreMapping_getMapping_args__isset;

        class BucketStoreMapping_getMapping_args {
        public:

            BucketStoreMapping_getMapping_args() : category() {
            }

            virtual ~BucketStoreMapping_getMapping_args() throw () {
            }

            std::string category;

            _BucketStoreMapping_getMapping_args__isset __isset;

            void __set_category(const std::string& val) {
                category = val;
            }

            bool operator==(const BucketStoreMapping_getMapping_args & rhs) const {
                if (!(category == rhs.category))
                    return false;
                return true;
            }

            bool operator!=(const BucketStoreMapping_getMapping_args &rhs) const {
                return !(*this == rhs);
            }

            bool operator<(const BucketStoreMapping_getMapping_args &) const;

            uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
            uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

        };

        class BucketStoreMapping_getMapping_pargs {
        public:

            virtual ~BucketStoreMapping_getMapping_pargs() throw () {
            }

            const std::string* category;

            uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

        };

        typedef struct _BucketStoreMapping_getMapping_result__isset {

            _BucketStoreMapping_getMapping_result__isset() : success(false), e(false) {
            }
            bool success;
            bool e;
        } _BucketStoreMapping_getMapping_result__isset;

        class BucketStoreMapping_getMapping_result {
        public:

            BucketStoreMapping_getMapping_result() {
            }

            virtual ~BucketStoreMapping_getMapping_result() throw () {
            }

            std::map<int32_t, HostPort> success;
            BucketStoreMappingException e;

            _BucketStoreMapping_getMapping_result__isset __isset;

            void __set_success(const std::map<int32_t, HostPort> & val) {
                success = val;
            }

            void __set_e(const BucketStoreMappingException& val) {
                e = val;
            }

            bool operator==(const BucketStoreMapping_getMapping_result & rhs) const {
                if (!(success == rhs.success))
                    return false;
                if (!(e == rhs.e))
                    return false;
                return true;
            }

            bool operator!=(const BucketStoreMapping_getMapping_result &rhs) const {
                return !(*this == rhs);
            }

            bool operator<(const BucketStoreMapping_getMapping_result &) const;

            uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
            uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

        };

        typedef struct _BucketStoreMapping_getMapping_presult__isset {

            _BucketStoreMapping_getMapping_presult__isset() : success(false), e(false) {
            }
            bool success;
            bool e;
        } _BucketStoreMapping_getMapping_presult__isset;

        class BucketStoreMapping_getMapping_presult {
        public:

            virtual ~BucketStoreMapping_getMapping_presult() throw () {
            }

            std::map<int32_t, HostPort> * success;
            BucketStoreMappingException e;

            _BucketStoreMapping_getMapping_presult__isset __isset;

            uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

        };

        class BucketStoreMappingClient : virtual public BucketStoreMappingIf {
        public:

            BucketStoreMappingClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
            piprot_(prot),
            poprot_(prot) {
                iprot_ = prot.get();
                oprot_ = prot.get();
            }

            BucketStoreMappingClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
            piprot_(iprot),
            poprot_(oprot) {
                iprot_ = iprot.get();
                oprot_ = oprot.get();
            }

            boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
                return piprot_;
            }

            boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
                return poprot_;
            }
            void getMapping(std::map<int32_t, HostPort> & _return, const std::string& category);
            void send_getMapping(const std::string& category);
            void recv_getMapping(std::map<int32_t, HostPort> & _return);
        protected:
            boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
            boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
            ::apache::thrift::protocol::TProtocol* iprot_;
            ::apache::thrift::protocol::TProtocol* oprot_;
        };

        class BucketStoreMappingProcessor : public ::apache::thrift::TDispatchProcessor {
        protected:
            boost::shared_ptr<BucketStoreMappingIf> iface_;
            virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
        private:
            typedef void (BucketStoreMappingProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
            typedef std::map<std::string, ProcessFunction> ProcessMap;
            ProcessMap processMap_;
            void process_getMapping(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
        public:

            BucketStoreMappingProcessor(boost::shared_ptr<BucketStoreMappingIf> iface) :
            iface_(iface) {
                processMap_["getMapping"] = &BucketStoreMappingProcessor::process_getMapping;
            }

            virtual ~BucketStoreMappingProcessor() {
            }
        };

        class BucketStoreMappingProcessorFactory : public ::apache::thrift::TProcessorFactory {
        public:

            BucketStoreMappingProcessorFactory(const ::boost::shared_ptr< BucketStoreMappingIfFactory >& handlerFactory) :
            handlerFactory_(handlerFactory) {
            }

            ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

        protected:
            ::boost::shared_ptr< BucketStoreMappingIfFactory > handlerFactory_;
        };

        class BucketStoreMappingMultiface : virtual public BucketStoreMappingIf {
        public:

            BucketStoreMappingMultiface(std::vector<boost::shared_ptr<BucketStoreMappingIf> >& ifaces) : ifaces_(ifaces) {
            }

            virtual ~BucketStoreMappingMultiface() {
            }
        protected:
            std::vector<boost::shared_ptr<BucketStoreMappingIf> > ifaces_;

            BucketStoreMappingMultiface() {
            }

            void add(boost::shared_ptr<BucketStoreMappingIf> iface) {
                ifaces_.push_back(iface);
            }
        public:

            void getMapping(std::map<int32_t, HostPort> & _return, const std::string& category) {
                size_t sz = ifaces_.size();
                size_t i = 0;
                for (; i < (sz - 1); ++i) {
                    ifaces_[i]->getMapping(_return, category);
                }
                ifaces_[i]->getMapping(_return, category);
                return;
            }

        };

    }
} // namespace

#endif
